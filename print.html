<!DOCTYPE HTML>
<html lang="en" class="ayu" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>More Configuration Documentation</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        <link rel="stylesheet" href="theme/custom.css">

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "ayu";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('ayu')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded affix "><a href="index.html">Introduction</a></li><li class="chapter-item expanded affix "><li class="part-title">User Guide</li><li class="chapter-item expanded "><a href="getting-started.html"><strong aria-hidden="true">1.</strong> Getting Started</a></li><li class="chapter-item expanded affix "><li class="part-title">Reference Guide</li><li class="chapter-item expanded "><a href="guide/abstractions.html"><strong aria-hidden="true">2.</strong> Abstractions</a></li><li class="chapter-item expanded "><a href="guide/data.html"><strong aria-hidden="true">3.</strong> Working With Data</a></li><li class="chapter-item expanded "><a href="guide/files.html"><strong aria-hidden="true">4.</strong> File Sources</a></li><li class="chapter-item expanded "><a href="guide/memory.html"><strong aria-hidden="true">5.</strong> In-Memory Provider</a></li><li class="chapter-item expanded "><a href="guide/env.html"><strong aria-hidden="true">6.</strong> Environment Variable Provider</a></li><li class="chapter-item expanded "><a href="guide/cmd.html"><strong aria-hidden="true">7.</strong> Command-Line Provider</a></li><li class="chapter-item expanded "><a href="guide/json.html"><strong aria-hidden="true">8.</strong> JSON Provider</a></li><li class="chapter-item expanded "><a href="guide/xml.html"><strong aria-hidden="true">9.</strong> XML Provider</a></li><li class="chapter-item expanded "><a href="guide/ini.html"><strong aria-hidden="true">10.</strong> INI Provider</a></li><li class="chapter-item expanded "><a href="guide/chained.html"><strong aria-hidden="true">11.</strong> Chained Provider</a></li><li class="chapter-item expanded "><a href="guide/binding.html"><strong aria-hidden="true">12.</strong> Data Binding</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">More Configuration Documentation</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/commonsensesoftware/more-rs-config/tree/main/guide" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p><code>more-config</code> is a crate containing all of the fundamental abstractions for configuration in Rust.</p>
<h2 id="features"><a class="header" href="#features">Features</a></h2>
<p>This crate provides the following features:</p>
<ul>
<li><em>default</em> - Abstractions for configuration, including the <strong>std</strong> features</li>
<li><strong>std</strong> - Standard configuration implementation</li>
<li><strong>all</strong> - Includes all features, except <strong>async</strong></li>
<li><strong>async</strong> - Use configuration in an asynchronous context</li>
<li><strong>mem</strong> - An in-memory configuration source</li>
<li><strong>env</strong> - An environment variables configuration source</li>
<li><strong>cmd</strong> - A command-line argument configuration source</li>
<li><strong>json</strong> - A *.json file configuration source</li>
<li><strong>xml</strong> - A *.xml file configuration source</li>
<li><strong>ini</strong> - An *.ini file configuration source</li>
<li><strong>chained</strong> - Chain multiple configuration sources</li>
<li><strong>binder</strong> - Bind a configuration to strongly-typed values and structs</li>
</ul>
<blockquote>
<p>Use <code>--features all,async</code> for all features with asynchronous support</p>
</blockquote>
<h2 id="contributing"><a class="header" href="#contributing">Contributing</a></h2>
<p><code>more-config</code> is free and open source. You can find the source code on <a href="https://github.com/commonsensesoftware/more-rs-config">GitHub</a>
and issues and feature requests can be posted on the <a href="https://github.com/commonsensesoftware/more-rs-config/issues">GitHub issue tracker</a>.
<code>more-config</code> relies on the community to fix bugs and add features: if you'd like to contribute, please read the
<a href="https://github.com/commonsensesoftware/more-rs-config/blob/main/CONTRIBUTING.md">CONTRIBUTING</a> guide and consider opening
a <a href="https://github.com/commonsensesoftware/more-rs-config/pulls">pull request</a>.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>This project is licensed under the <a href="https://github.com/commonsensesoftware/more-rs-config/blob/main/LICENSE">MIT</a> license.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h1>
<p>The simplest way to get started is to install the crate using all features.</p>
<pre><code class="language-bash">cargo add more-config --features all
</code></pre>
<p>This includes all features <em>except</em> the <strong>async</strong> feature. The <strong>async</strong> feature intersects with all other features. If you would like all features with asynchronous support use:</p>
<pre><code class="language-bash">cargo add more-config --features all,async
</code></pre>
<p>Once you know which configuration sources you want to support, you can limit the features to only the ones you need.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>Configuration is a common requirement of virtually any application and can be performed using one or more configuration providers. Configuration providers read configuration data from key-value pairs using a variety of configuration sources:</p>
<ul>
<li>Settings files, such as <code>appsettings.json</code></li>
<li>Environment variables</li>
<li>Command-line arguments</li>
<li>In-memory data structures</li>
<li>Custom providers</li>
</ul>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_in_memory(&amp;[("MyKey", "MyValue")])
        .add_json_file("appsettings.json".is().optional())
        .add_env_vars()
        .add_command_line()
        .build()
        .unwrap();

    println!("MyKey = {}", config.get("MyKey").unwrap().as_str());
}</code></pre>
<p>Configuration providers that are added later have higher priority and override previous key settings. For example, if <code>MyKey</code> is set in both <code>appsettings.json</code> and an environment variable, then the environment variable value is used. If <code>appsettings.json</code> does not exist or contain <code>MyKey</code> and there is no environment variable for <code>MyKey</code>, then the in-memory value of <code>MyValue</code> is used. Finally, if command-line argument <code>--MyKey</code> is provided, it overrides all other values.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="abstractions"><a class="header" href="#abstractions">Abstractions</a></h1>
<p>The configuration framework contains a common set of traits and behaviors for numerous scenarios.</p>
<h2 id="configuration"><a class="header" href="#configuration">Configuration</a></h2>
<p>The <a href="https://docs.rs/more-config/2.0.0/config/trait.Configuration.html"><code>Configuration</code></a> trait is the pinnacle of the entire framework. It defines the behaviors to retrieve a configured value or iterate over all key-value pairs, access or traverse child sections, and react to a reload triggered by the underlying configuration source.</p>
<pre><code class="language-rust">pub trait Configuration {
    fn get(&amp;self, key: &amp;str) -&gt; Option&lt;Value&gt;;
    fn section(&amp;self, key: &amp;str) -&gt; Box&lt;dyn ConfigurationSection&gt;;
    fn children(&amp;self) -&gt; Vec&lt;Box&lt;dyn ConfigurationSection&gt;&gt;;
    fn reload_token(&amp;self) -&gt; Box&lt;dyn ChangeToken&gt;;
    fn as_section(&amp;self) -&gt; Option&lt;&amp;dyn ConfigurationSection&gt;;
    fn iter(
        &amp;self,
        path: Option&lt;ConfigurationPath&gt;
    ) -&gt; Box&lt;dyn Iterator&lt;Item = (String, Value)&gt;&gt;;
}</code></pre>
<h2 id="configuration-section"><a class="header" href="#configuration-section">Configuration Section</a></h2>
<p>Hierarchical configurations are divided into <em>sections</em>. A configurations section is itself a nested <a href="https://docs.rs/more-config/2.0.0/config/trait.Configuration.html"><code>Configuration</code></a>. A configuration section also has its own key and, possibly, a value. A configuration section which does not have a value will always yield an empty string.</p>
<pre><code class="language-rust">pub trait ConfigurationSection:
    Configuration
    + AsRef&lt;dyn Configuration&gt;
    + Borrow&lt;dyn Configuration&gt;
    + Deref&lt;Target = dyn Configuration&gt;
{
    fn key(&amp;self) -&gt; &amp;str;
    fn path(&amp;self) -&gt; &amp;str;
    fn value(&amp;self) -&gt; Value;
    fn as_config(&amp;self) -&gt; Box&lt;dyn Configuration&gt;;
}</code></pre>
<h2 id="configuration-root"><a class="header" href="#configuration-root">Configuration Root</a></h2>
<p>Every configuration has a single root. The root configuration knows about all of the associated <a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationProvider.html"><code>ConfigurationProvider</code></a> instances and can reload the entire configuration.</p>
<pre><code class="language-rust">pub trait ConfigurationRoot:
    Configuration
    + AsRef&lt;dyn Configuration&gt;
    + Borrow&lt;dyn Configuration&gt;
    + Deref&lt;Target = dyn Configuration&gt;
    + Debug
{
    fn reload(&amp;mut self) -&gt; ReloadResult;
    fn providers(&amp;self) -&gt; Box&lt;dyn ConfigurationProviderIterator + '_&gt;;
    fn as_config(&amp;self) -&gt; Box&lt;dyn Configuration&gt;;
}</code></pre>
<h1 id="configuration-provider"><a class="header" href="#configuration-provider">Configuration Provider</a></h1>
<p>A configuration provider is responsible for loading configuration from a source. A configuration provider might support automatic reloading and can advertise when a reload has occurred via a reload <a href="https://docs.rs/more-changetoken/2.0.0/tokens/trait.ChangeToken.html"><code>ChangeToken</code></a>.</p>
<pre><code class="language-rust">pub trait ConfigurationProvider {
    fn name(&amp;self) -&gt; &amp;str;
    fn get(&amp;self, key: &amp;str) -&gt; Option&lt;Value&gt;;
    fn reload_token(&amp;self) -&gt; Box&lt;dyn ChangeToken&gt;;
    fn load(&amp;mut self) -&gt; LoadResult;
    fn child_keys(&amp;self, earlier_keys: &amp;mut Vec&lt;String&gt;, parent_path: Option&lt;&amp;str&gt;);
}</code></pre>
<h1 id="configuration-source"><a class="header" href="#configuration-source">Configuration Source</a></h1>
<p>A configuration source provides an abstraction over a source for configuration such as a file. The source accepts all of the information required to setup a provider and then constructs it when the configuration is built.</p>
<pre><code class="language-rust">pub trait ConfigurationSource {
    fn build(
        &amp;self,
        builder: &amp;dyn ConfigurationBuilder
    ) -&gt; Box&lt;dyn ConfigurationProvider&gt;;
}</code></pre>
<h2 id="configuration-builder"><a class="header" href="#configuration-builder">Configuration Builder</a></h2>
<p>A configuration builder accumulates one or more configuration sources and then builds a <a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationRoot.html"><code>ConfigurationRoot</code></a>. The configuration is immediately reloaded so that it is ready to use.</p>
<pre><code class="language-rust">pub trait ConfigurationBuilder {
    fn properties(&amp;self) -&gt; &amp;HashMap&lt;String, Box&lt;dyn Any&gt;&gt;;
    fn sources(&amp;self) -&gt; &amp;[Box&lt;dyn ConfigurationSource&gt;];
    fn add(&amp;mut self, source: Box&lt;dyn ConfigurationSource&gt;);
    fn build(&amp;self) -&gt; Result&lt;Box&lt;dyn ConfigurationRoot&gt;, ReloadError&gt;;
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="working-with-configuration-data"><a class="header" href="#working-with-configuration-data">Working With Configuration Data</a></h1>
<p>There are several different ways to work with configuration data. <a href="guide/abstractions.html#configuration-source">Configuration sources</a> are normalized to a generic key-value pair format, which can then be merged and consumed universally; regardless of the original format.</p>
<h2 id="hierarchical-configuration-data"><a class="header" href="#hierarchical-configuration-data">Hierarchical Configuration Data</a></h2>
<p>The Configuration API reads hierarchical configuration data by flattening the hierarchical data with the use of a delimiter in the configuration keys.</p>
<p>Consider the following <code>appsettings.json</code> file:</p>
<pre><code class="language-json">{
  "Position": {
    "Title": "Editor",
    "Name": "Joe Smith"
  },
  "MyKey": "My appsettings.json Value",
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "App": "Warning",
      "App.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
</code></pre>
<p>The following code displays several of the configurations settings:</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_json_file("appsettings.json")
        .build()
        .unwrap();

    let my_key_value = config.get("MyKey").unwrap().as_str();
    let title = config.get("Position:Title").unwrap().as_str();
    let name = config.section("Position").get("Name").unwrap().as_str();
    let default_log_level = config.get("Logging:LogLevel:Default").unwrap().as_str();

    println!("MyKey value: {}\n\
              Title: {}\n\
              Name: {}\n\
              Default Log Level: {}",
              my_key_value,
              title,
              name,
              default_log_level);
}</code></pre>
<p>The preferred way to read hierarchical configuration data is using the <em>Options</em> pattern provided by the <a href="https://crates.io/crates/more-options">more-options</a> crate. The <a href="https://docs.rs/more-config/2.0.0/config/trait.Configuration.html#method.section"><code>section</code></a> and <a href="https://docs.rs/more-config/2.0.0/config/trait.Configuration.html#method.children"><code>children</code></a> methods are available to isolate sections and children of a section in the configuration data.</p>
<h2 id="configuration-keys-and-values"><a class="header" href="#configuration-keys-and-values">Configuration Keys and Values</a></h2>
<p>Configuration keys:</p>
<ul>
<li>Are case-insensitive; for example, <code>ConnectionString</code> and <code>connectionstring</code> are treated as equivalent keys.</li>
<li>If a key and value is set in more than one <a href="guide/abstractions.html#configuration-provider">configuration providers</a>, the value from the last provider added is used.</li>
<li>Hierarchical keys
<ul>
<li>Within the Configuration API, a colon separator (<code>:</code>) works on all platforms.</li>
<li>In environment variables, a colon separator may not work on all platforms. A double underscore, <code>__</code>, is supported by all platforms and is automatically converted into a colon <code>:</code>.</li>
</ul>
</li>
<li>The <a href="guide/binding.html"><code>ConfigurationBinder</code></a> supports binding arrays to objects using array indices in configuration keys.</li>
</ul>
<p>Configuration values:</p>
<ul>
<li>Are strings</li>
<li>Null values can't be stored in configuration or bound to objects</li>
</ul>
<h2 id="get-value"><a class="header" href="#get-value">Get Value</a></h2>
<p>The <a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationBinder.html#method.get_value"><code>get_value</code></a> and <a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationBinder.html#method.get_value_or_default"><code>get_value_or_default</code></a> methods extract a single value from configuration with a specified key and converts it to the specified type.</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_json_file("settings.json")
        .build()
        .unwrap();

    let number: Option&lt;u8&gt; = config.get_value("NumberKey").unwrap().unwrap_or(99);
    let flag: bool = config.get_value_or_default("Enabled").unwrap();

    println!("Number = {}", number);
    println!("Flag = {}", flag);
}</code></pre>
<p>In the preceding code, if <code>NumberKey</code> isn't found in the configuration, the default value of <code>99</code> is used. If <code>Enabled</code> isn't found in the configuration, it will default to <code>false</code>, which is the <code>Default::default()</code> for <code>bool</code>.</p>
<h2 id="section-children-and-exists"><a class="header" href="#section-children-and-exists">Section, Children, and Exists</a></h2>
<p>For the examples that follow, consider the following <code>MySubsection.json</code> file:</p>
<pre><code class="language-json">{
  "section0": {
    "key0": "value00",
    "key1": "value01"
  },
  "section1": {
    "key0": "value10",
    "key1": "value11"
  },
  "section2": {
    "subsection0": {
      "key0": "value200",
      "key1": "value201"
    },
    "subsection1": {
      "key0": "value210",
      "key1": "value211"
    }
  }
}
</code></pre>
<h3 id="section"><a class="header" href="#section">Section</a></h3>
<p><a href="https://docs.rs/more-config/2.0.0/config/trait.Configuration.html#method.section"><code>section</code></a> returns a configuration subsection with the specified subsection key.</p>
<p>The following code returns values for <code>section1</code>:</p>
<pre><code class="language-rust">let section = config.section("section1");

println!("section1:key0: {}\n\
          section1:key1: {}",
          section.get("key0").unwrap().as_str(),
          section.get("key1").unwrap().as_str());</code></pre>
<p>The following code returns values for <code>section2:subsection0</code>:</p>
<pre><code class="language-rust">let section = config.section("section2:subsection0");

println!("section2:subsection0:key0: {}\n\
          section2:subsection0:key0: {}",
          section.get("key0").unwrap().as_str(),
          section.get("key1").unwrap().as_str());</code></pre>
<p>If a matching section isn't found, an empty <a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationSection.html"><code>ConfigurationSection</code></a> is returned.</p>
<h3 id="children-and-exists"><a class="header" href="#children-and-exists">Children and Exists</a></h3>
<p>The following code calls <a href="https://docs.rs/more-config/2.0.0/config/trait.Configuration.html#method.children"><code>children</code></a> and returns values for <code>section2:subsection0</code>:</p>
<pre><code class="language-rust">let section = config.section("section2");

if section.exists() {
  for subsection in section.children() {
    let key1 = format!("{}:key0", section.key());
    let key2 = format!("{}:key1", section.key());
    
    println!("{} value: {}\n\
              {} value: {}",
              &amp;key1,
              &amp;key2,
              section.get(&amp;key1).unwrap().as_str(),
              section.get(&amp;key2).unwrap().as_str());
  }
} else {
  println!("section2 does not exist.");
}

println!("section1:key0: {}\n\
          section1:key1: {}",
          section.get("key0").unwrap().as_str(),
          section.get("key1").unwrap().as_str());</code></pre>
<p>The preceding code uses the <a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationSectionExtensions.html#method.exists"><code>exists</code></a> extension to verify the section exists.</p>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="working-with-files"><a class="header" href="#working-with-files">Working With Files</a></h1>
<p>A <a href="guide/abstractions.html#configuration-provider"><code>ConfigurationProvider</code></a> that is based on a file should support a <a href="https://docs.rs/more-config/2.0.0/config/struct.FileSource.html"><code>FileSource</code></a>:</p>
<pre><code class="language-rust">pub struct FileSource {
    pub path: PathBuf,
    pub optional: bool,
    pub reload_on_change: bool,
    pub reload_delay: Duration,
}</code></pre>
<p>An <a href="https://docs.rs/more-config/2.0.0/config/struct.FileSource.html#method.optional"><code>optional</code></a> file means that the <a href="https://docs.rs/more-config/2.0.0/config/struct.FileSource.html#method.path"><code>path</code></a> does not need to exist. When <a href="https://docs.rs/more-config/2.0.0/config/struct.FileSource.html#method.reload_on_change"><code>reload_on_change</code></a> is specified, the provider will watch for changes to <a href="https://docs.rs/more-config/2.0.0/config/struct.FileSource.html#method.path"><code>path</code></a> and trigger a notification via <a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationProvider.html#method.reload_token"><code>ConfigurationProvider::reload_token</code></a>. A file change might trigger before a file has been completely written, which is operating system dependent. <a href="https://docs.rs/more-config/2.0.0/config/struct.FileSource.html#method.reload_delay"><code>reload_delay</code></a> indicates how long a provider should wait to reload when a change is detected. The default duration is 250 milliseconds.</p>
<p>All of the built-in, file-based configuration providers support accepting a <a href="https://docs.rs/more-config/2.0.0/config/struct.FileSource.html"><code>FileSource</code></a>. A file source is most commonly just a file path, but it may include additional configuration features. The <a href="https://docs.rs/more-config/2.0.0/config/struct.FileSourceBuilder.html"><code>FileSourceBuilder</code></a> struct and <a href="https://docs.rs/more-config/2.0.0/config/trait.FileSourceBuilderExtensions.html"><code>FileSourceBuilderExtensions</code></a> trait provide several methods of specifying a <a href="https://docs.rs/more-config/2.0.0/config/struct.FileSource.html"><code>FileSource</code></a> and its options in a fluent manner.</p>
<pre><code class="language-rust">use config::{*, ext::*};
use std::path::PathBuf;

fn main() {
    let xml = PathBuf::from("settings.xml");
    let config = DefaultConfigurationBuilder::new()
        .add_ini_file(FileSource::new(PathBuf::("prod.cfg.ini"), false, false, None))
        .add_ini_file(FileSource::optional(PathBuf::("dev.cfg.ini")))
        .add_xml_file(xml.is().optional())
        .add_json_file("settings.json".is().optional().reloadable())
        .build()
        .unwrap();

    for (key, value) in config.iter(None) {
        println!("{} = {}", key, value.as_str());
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="in-memory-configuration-provider"><a class="header" href="#in-memory-configuration-provider">In-Memory Configuration Provider</a></h1>
<blockquote>
<p>These features are only available if the <strong>mem</strong> feature is activated</p>
</blockquote>
<p>The <a href="https://docs.rs/more-config/2.0.0/config/struct.MemoryConfigurationProvider.html"><code>MemoryConfigurationProvider</code></a> uses an in-memory collection as configuration key-value pairs. This is most useful as a default configuration or when providing test values.</p>
<p>The following code adds a memory collection to the configuration system and displays the settings:</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_in_memory(&amp;[
            ("MyKey", "Dictionary MyKey Value"),
            ("Position:Title", "Dictionary_Title"),
            ("Position:Name", "Dictionary_Name"),
            ("Logging:LogLevel:Default", "Warning"),
        ])
        .build()
        .unwrap();

    let my_key_value = config.get("MyKey").unwrap().as_str();
    let title = config.get("Position:Title").unwrap().as_str();
    let name = config.section("Position").get("Name").unwrap().as_str();
    let default_log_level = config.get("Logging:LogLevel:Default").unwrap().as_str();

    println!("MyKey value: {}\n\
              Title: {}\n\
              Name: {}\n\
              Default Log Level: {}",
              my_key_value,
              title,
              name,
              default_log_level);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="environment-variable-configuration-provider"><a class="header" href="#environment-variable-configuration-provider">Environment Variable Configuration Provider</a></h1>
<blockquote>
<p>These features are only available if the <strong>env</strong> feature is activated</p>
</blockquote>
<p>The <a href="https://docs.rs/more-config/2.0.0/config/struct.EnvironmentVariablesConfigurationProvider.html"><code>EnvironmentVariablesConfigurationProvider</code></a> loads configuration from environment variable key-value pairs.</p>
<p>The <code>:</code> separator doesn't work with environment variable hierarchical keys on all platforms. <code>__</code>, the double underscore, is:</p>
<ul>
<li>Supported by all platforms; for example, the <code>:</code> separator is not supported by Bash, but <code>__</code> is.</li>
<li>Automatically replaced by a <code>:</code></li>
</ul>
<pre><code class="language-bash">export MyKey="My key from Environment"
export Position__Title=Console
export Position__Name="John Doe"
</code></pre>
<p>Call <a href="https://docs.rs/more-config/2.0.0/config/struct.EnvironmentVariablesExtensions.html#method.add_env_vars"><code>add_env_vars</code></a> to add environment variables or <a href="https://docs.rs/more-config/2.0.0/config/struct.EnvironmentVariablesExtensions.html#method.add_env_vars_with_prefix"><code>add_env_vars_with_prefix</code></a> with a string to specify a prefix for environment variables:</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
            .add_env_vars_with_prefix("MyCustomPrefix_")
            .build()
            .unwrap();
    
    for (key, value) in config.iter(None) {
        println!("{} = {}", key, value.as_str());
    }
}</code></pre>
<p>Environment variables set with the <code>MyCustomPrefix_</code> prefix override the default configuration providers. This includes environment variables without the prefix. The prefix is stripped off when the configuration key-value pairs are read.</p>
<pre><code class="language-bash">export MyCustomPrefix_MyKey="My key with MyCustomPrefix_ Environment"
export MyCustomPrefix_Position__Title="Custom Editor"
export MyCustomPrefix_Position__Name="Jane Doe"
</code></pre>
<h2 id="naming-of-environment-variables"><a class="header" href="#naming-of-environment-variables">Naming of Environment Variables</a></h2>
<p>Environment variable names reflect the structure of an <code>appsettings.json</code> file. Each element in the hierarchy is separated by a double underscore. When the element structure includes an array, the array index should be treated as an additional element name in this path. Consider the following <code>appsettings.json</code> file and its equivalent values represented as environment variables.</p>
<pre><code class="language-json">{
    "SmtpServer": "smtp.example.com",
    "Logging":
    [
        {
            "Name": "ToEmail",
            "Level": "Critical",
            "Args":
            {
                "FromAddress": "MySystem@example.com",
                "ToAddress": "SRE@example.com"
            }
        },
        {
            "Name": "ToConsole",
            "Level": "Information"
        }
    ]
}
</code></pre>
<pre><code class="language-bash">export SmtpServer=smtp.example.com
export Logging__0__Name=ToEmail
export Logging__0__Level=Critical
export Logging__0__Args__FromAddress=MySystem@example.com
export Logging__0__Args__ToAddress=SRE@example.com
export Logging__1__Name=ToConsole
export Logging__1__Level=Information
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="command-line-configuration-provider"><a class="header" href="#command-line-configuration-provider">Command-Line Configuration Provider</a></h1>
<blockquote>
<p>These features are only available if the <strong>cmd</strong> feature is activated</p>
</blockquote>
<p>The <a href="https://docs.rs/more-config/2.0.0/config/struct.CommandLineConfigurationProvider.html"><code>CommandLineConfigurationProvider</code></a> loads configuration from command-line argument key-value pairs. Configuration values set on the command-line can be used to override configuration values set with all the other configuration providers. When used, it is recommended that this is the last configuration provider added.</p>
<h2 id="command-line-arguments"><a class="header" href="#command-line-arguments">Command-line Arguments</a></h2>
<p>The following command sets keys and values using <code>=</code>:</p>
<pre><code class="language-bash">myapp MyKey="Using =" Position:Title=Cmd Position:Name=Cmd_Joe
</code></pre>
<p>The following command sets keys and values using <code>/</code>:</p>
<pre><code class="language-bash">myapp /MyKey "Using /" /Position:Title=Cmd /Position:Name=Cmd_Joe
</code></pre>
<p>The following command sets keys and values using <code>--</code>:</p>
<pre><code class="language-bash">myapp --MyKey "Using --" --Position:Title=Cmd --Position:Name=Cmd_Joe
</code></pre>
<p>The key value:</p>
<ul>
<li>Must follow <code>=</code>, or the key must have a prefix of <code>--</code> or <code>/</code> when the value follows a space.</li>
<li>Isn't required if <code>=</code> is used; for example, <code>MySetting=</code>.</li>
</ul>
<p>Within the same command, don't mix command-line argument key-value pairs that use <code>=</code> with key-value pairs that use a space.</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_command_line()
        .build()
        .unwrap();

    println!("Name = {}", config.section("Position").get("Name").unwrap());
}
</code></pre>
<h2 id="switch-mappings"><a class="header" href="#switch-mappings">Switch Mappings</a></h2>
<p>Switch mappings allow key name replacement logic. Provide a hash map of switch replacements to the <a href="https://docs.rs/more-config/2.0.0/config/trait.CommandLineConfigurationBuilderExtensions.html#method.add_command_line_map"><code>add_command_line_map</code></a> method.</p>
<p>When the switch mappings hash map is used, the hash map is checked for a key that matches the key provided by a command-line argument. If the command-line key is found in the hash map, the hash map value is passed back to set the key-value pair into the application's configuration. A
switch mapping is required for any command-line key prefixed with a single dash (<code>-</code>).</p>
<p>Switch mappings hash map key rules:</p>
<ul>
<li>Switches must start with <code>-</code> or <code>--</code>.</li>
<li>The switch mappings hash map must not contain duplicate keys.</li>
</ul>
<p>To use a switch mappings hash map, pass it into the call to <a href="https://docs.rs/more-config/2.0.0/config/trait.CommandLineConfigurationBuilderExtensions.html#method.add_command_line_map"><code>add_command_line_map</code></a>:</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let switch_mappings = [
        ("-k1", "key1"),
        ("-k2", "key2"),
        ("--alt3", "key3"),
        ("--alt4", "key4"),
        ("--alt5", "key5"),
        ("--alt6", "key6"),
    ];
    let config = DefaultConfigurationBuilder::new()
        .add_command_line_map(&amp;switch_mappings)
        .build()
        .unwrap();

    for (key, value) in config.iter(None) {
        println!("{} = {}", key, value.as_str());
    }
}</code></pre>
<p>Run the following command works to test key replacement:</p>
<pre><code class="language-bash">myapp -k1 value1 -k2 value2 --alt3=value2 /alt4=value3 --alt5 value5 /alt6 value6
</code></pre>
<p>The following code shows the key values for the replaced keys:</p>
<pre><code class="language-rust">println!("Key1: {}\n\
          Key2: {}\n\
          Key3: {}\n\
          Key4: {}\n\
          Key5: {}\n\
          Key6: {}",
          config.get("Key1").unwrap(),
          config.get("Key2").unwrap(),
          config.get("Key3").unwrap(),
          config.get("Key4").unwrap(),
          config.get("Key5").unwrap(),
          config.get("Key6").unwrap());</code></pre>
<h2 id="filtering"><a class="header" href="#filtering">Filtering</a></h2>
<p>By default, the sequence of arguments provided by <code>std::env::args()</code> is supplied to the <a href="https://docs.rs/more-config/2.0.0/config/struct.CommandLineConfigurationSource.html"><code>CommandLineConfigurationSource</code></a>. If custom filtering is required, no extension method is provided to do so. The setup is still trivial albeit more verbose.</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let mut args: Vec&lt;_&gt; = std::env::args().collect();

    // TODO: apply filtering

    let cmd = CommandLineConfigurationSource::from(args.iter());
    let mut builder = DefaultConfigurationBuilder::new();

    builder.add(Box::new(cmd));

    let config = builder.build().unwrap();

    for (key, value) in config.iter(None) {
        println!("{} = {}", key, value.as_str());
    }
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="json-configuration-provider"><a class="header" href="#json-configuration-provider">JSON Configuration Provider</a></h1>
<blockquote>
<p>These features are only available if the <strong>json</strong> feature is activated</p>
</blockquote>
<p>The <a href="https://docs.rs/more-config/2.0.0/config/struct.JsonConfigurationProvider.html"><code>JsonConfigurationProvider</code></a> supports loading configuration from a <code>*.json</code> file.</p>
<p>Consider the following <code>appsettings.json</code> file:</p>
<pre><code class="language-json">{
  "Position": {
    "Title": "Editor",
    "Name": "Joe Smith"
  },
  "MyKey": "My appsettings.json Value",
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "App": "Warning",
      "App.Hosting.Lifetime": "Information"
    }
  },
  "AllowedHosts": "*"
}
</code></pre>
<p>The following code displays several of the preceding configurations settings:</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_json_file("appsettings.json")
        .build()
        .unwrap();

    let my_key_value = config.get("MyKey").unwrap().as_str();
    let title = config.get("Position:Title").unwrap().as_str();
    let name = config.section("Position").get("Name").unwrap().as_str();
    let default_log_level = config.get("Logging:LogLevel:Default").unwrap().as_str();

    println!("MyKey value: {}\n\
              Title: {}\n\
              Name: {}\n\
              Default Log Level: {}",
              my_key_value,
              title,
              name,
              default_log_level);
}</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="xml-configuration-provider"><a class="header" href="#xml-configuration-provider">XML Configuration Provider</a></h1>
<blockquote>
<p>These features are only available if the <strong>xml</strong> feature is activated</p>
</blockquote>
<p>The <a href="https://docs.rs/more-config/2.0.0/config/struct.XmlConfigurationProvider.html"><code>XmlConfigurationProvider</code></a> supports loading configuration from a <code>*.xml</code> file.</p>
<p>The following code adds several configuration providers, including a couple of <code>*.xml</code> files:</p>
<pre><code class="language-rust">fn main() {
    let name = env::var("ENVIRONMENT").or_else("production");
    let config = DefaultConfigurationBuilder::new()
        .add_xml_file("MyXmlConfig.xml".is().optional())
        .add_xml_file(format!("MyXmlConfig.{}.xml", name).is().optional())
        .add_env_vars()
        .add_command_line()
        .build()
        .unwrap();
}</code></pre>
<p>The XML configuration files have a few special rules that are different from other <a href="guide/abstractions.html#configuration-provider">configuration providers</a>:</p>
<ol>
<li>XML namespaces are not supported on elements or attributes</li>
<li>The <code>Name</code> attribute (case-insensitive) is considered as a surrogate key in lieu of the element it is applied to</li>
<li>Duplicate key-value combinations are ambiguous and not allowed</li>
<li>Repeating elements with different values are considered <em>array-like</em></li>
</ol>
<p>Consider the following configuration file:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8" ?&gt;
&lt;configuration&gt;
  &lt;MyKey&gt;MyXMLFile Value&lt;/MyKey&gt;
  &lt;Position&gt;
    &lt;Title&gt;Title from  MyXMLFile&lt;/Title&gt;
    &lt;Name&gt;Name from MyXMLFile&lt;/Name&gt;
  &lt;/Position&gt;
  &lt;Logging&gt;
    &lt;LogLevel&gt;
      &lt;Default&gt;Information&lt;/Default&gt;
      &lt;App&gt;Warning&lt;/App&gt;
    &lt;/LogLevel&gt;
  &lt;/Logging&gt;
&lt;/configuration&gt;
</code></pre>
<p>The following code displays several of the preceding configuration settings:</p>
<pre><code class="language-rust">let my_key_value = config.get("MyKey").unwrap().as_str();
let title = config.get("Position:Title").unwrap().as_str();
let name = config.section("Position").get("Name").unwrap().as_str();
let default_log_level = config.get("Logging:LogLevel:Default").unwrap().as_str();

println!("MyKey value: {}\n\
          Title: {}\n\
          Name: {}\n\
          Default Log Level: {}",
          my_key_value,
          title,
          name,
          default_log_level);</code></pre>
<p>Repeating elements that use the same element name work if the <code>name</code> attribute is used to distinguish the elements:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;section name="section0"&gt;
    &lt;key name="key0"&gt;value 00&lt;/key&gt;
    &lt;key name="key1"&gt;value 01&lt;/key&gt;
  &lt;/section&gt;
  &lt;section name="section1"&gt;
    &lt;key name="key0"&gt;value 10&lt;/key&gt;
    &lt;key name="key1"&gt;value 11&lt;/key&gt;
  &lt;/section&gt;
&lt;/configuration&gt;
</code></pre>
<p>The following code reads the previous configuration file and displays the keys and values:</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_xml_file("MyXmlConfig2.xml")
        .build()
        .unwrap();

    let val00 = config.get("section:section0:key:key0").unwrap().as_str();
    let val01 = config.get("section:section0:key:key1").unwrap().as_str();
    let val10 = config.get("section:section1:key:key0").unwrap().as_str();
    let val11 = config.get("section:section1:key:key1").unwrap().as_str();

    println!("section:section0:key:key0 value: {}\n\
              section:section0:key:key1 value: {}\n\
              section:section1:key:key0 value: {}\n\
              section:section1:key:key1 value: {}",
              val00
              val01
              val10
              val11);
}</code></pre>
<p>If the <code>name</code> attribute were not used, then the elements would be treated as <em>array-like</em>:</p>
<ul>
<li>section:0:key:0</li>
<li>section:0:key:1</li>
<li>section:1:key:0</li>
<li>section:1:key:1</li>
</ul>
<p>Attributes can also be used to supply values:</p>
<pre><code class="language-xml">&lt;?xml version="1.0" encoding="utf-8"?&gt;
&lt;configuration&gt;
  &lt;key attribute="value" /&gt;
  &lt;section&gt;
    &lt;key attribute="value" /&gt;
  &lt;/section&gt;
&lt;/configuration&gt;
</code></pre>
<p>The previous configuration file loads the following keys with value of <code>value</code>:</p>
<ul>
<li>key:attribute</li>
<li>section:key:attribute</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="ini-configuration-provider"><a class="header" href="#ini-configuration-provider">INI Configuration Provider</a></h1>
<blockquote>
<p>These features are only available if the <strong>ini</strong> feature is activated</p>
</blockquote>
<p>The <a href="https://docs.rs/more-config/2.0.0/config/struct.IniConfigurationProvider.html"><code>IniConfigurationProvider</code></a> supports loading configuration from an <code>*.ini</code> file.</p>
<p>The following code adds several configuration providers, including a couple of <code>*.ini</code> files:</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let name = std::env::var("ENVIRONMENT").or_else("production");
    let config = DefaultConfigurationBuilder::new()
        .add_ini_file("MyIniConfig.ini".is().optional())
        .add_ini_file(format!("MyIniConfig.{}.ini", name).is().optional())
        .add_env_vars()
        .add_command_line()
        .build()
        .unwrap();
}</code></pre>
<p>In the preceding code, settings in the <code>MyIniConfig.ini</code> and <code>MyIniConfig.{Environment}.ini</code> files are overridden by settings in the:</p>
<ul>
<li>Environment variables configuration provider</li>
<li>Command-line configuration provider</li>
</ul>
<p>Assume the <code>MyIniConfig.ini</code> file contains:</p>
<pre><code class="language-ini">MyKey="MyIniConfig.ini Value"

[Position]
Title="My INI Config title"
Name="My INI Config name"

[Logging:LogLevel]
Default=Information
App=Warning
</code></pre>
<p>The following code displays several of the preceding configurations settings:</p>
<pre><code class="language-rust">let my_key_value = config.get("MyKey").unwrap().as_str();
let title = config.get("Position:Title").unwrap().as_str();
let name = config.section("Position").get("Name").unwrap().as_str();
let default_log_level = config.get("Logging:LogLevel:Default").unwrap().as_str();

println!("MyKey value: {}\n\
          Title: {}\n\
          Name: {}\n\
          Default Log Level: {}",
          my_key_value,
          title,
          name,
          default_log_level);</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="chained-configuration-provider"><a class="header" href="#chained-configuration-provider">Chained Configuration Provider</a></h1>
<blockquote>
<p>These features are only available if the <strong>chained</strong> feature is activated</p>
</blockquote>
<p>Although it is not a very common usage scenario, you may encounter a scenario where you need to <em>chain</em> multiple <a href="guide/abstractions.html#configuration">configurations</a> from different sources into a unified <a href="guide/abstractions.html#configuration">configuration</a>. A practical example would be distinct <a href="guide/abstractions.html#configuration">configurations</a> defined by different crates.</p>
<p>Let's assume that <code>crate1</code> defines its default configuration as:</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn default_config() -&gt; Box&lt;dyn ConfigurationRoot&gt; {
    DefaultConfigurationBuilder::new()
        .add_in_memory(&amp;[("Mem1:KeyInMem1", "ValueInMem1")])
        .add_in_memory(&amp;[("Mem2:KeyInMem2", "ValueInMem2")])
        .build()
        .unwrap()
}</code></pre>
<p>Let's assume that <code>crate2</code> defines its default configuration as:</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn default_config() -&gt; Box&lt;dyn ConfigurationRoot&gt; {
    DefaultConfigurationBuilder::new()
        .add_in_memory(&amp;[("Mem3:KeyInMem3", "ValueInMem3")])
        .build()
        .unwrap()
}</code></pre>
<p>An application can now compose the <code>crate1</code> and <code>crate2</code> configurations into its own configuration.</p>
<pre><code class="language-rust">use config::{*, ext::*};
use crate1;
use crate2;

fn main() {
    let root = DefaultConfigurationBuilder::new()
        .add_configuration(crate1::default_config().as_config())
        .add_configuration(crate2::default_config().as_config())
        .add_env_vars()
        .add_command_line()
        .build()
        .unwrap();

    println!("mem1:keyinmem1 = {}", root.get("mem1:keyinmem1").unwrap());
    println!("Mem2:KeyInMem2 = {}", root.get("Mem2:KeyInMem2").unwrap());
    println!("MEM3:KEYINMEM3 = {}", root.get("ValueInMem3").unwrap());
}</code></pre>
<p>This configuration would output:</p>
<pre><code class="language-text">mem1:keyinmem1 = mem1:keyinmem1
Mem2:KeyInMem2 = Mem2:KeyInMem2
MEM3:KEYINMEM3 = ValueInMem3
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><!--
This file contains links that can be shared across pages. RustDoc links cannot currently
be used by mdBook directly. Links are stable on crates.io so we can centralize what is
required in this file, albeit manually.

REF: https://github.com/rust-lang/mdBook/issues/1356
REF: https://github.com/rust-lang/cargo/issues/739
REF: https://github.com/tag1consulting/goose/issues/320
-->
<h1 id="data-binding"><a class="header" href="#data-binding">Data Binding</a></h1>
<blockquote>
<p>Data binding requires the <strong>binder</strong> feature, which will also trigger activation of the optional <strong>serde</strong> dependency and is required for deserialization.</p>
</blockquote>
<p>Data binding leverages the <a href="https://crates.io/crates/serde">serde</a> crate to enable deserializing configurations in part, or in whole, into strongly-typed structures. It is also possible to retrieve strongly-typed scalar values.</p>
<p>A <a href="guide/abstractions.html#configuration"><code>Configuration</code></a> is deserialized through the <a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationBinder.html"><code>ConfigurationBinder</code></a> trait:</p>
<pre><code class="language-rust">pub trait ConfigurationBinder {
   fn reify&lt;T: DeserializeOwned&gt;(&amp;self) -&gt; T;
   fn bind&lt;T: DeserializeOwned&gt;(&amp;self, instance: &amp;mut T);
   fn bind_at&lt;T: DeserializeOwned&gt;(&amp;self, key: impl AsRef&lt;str&gt;, instance: &amp;mut T);
   fn get_value&lt;T: FromStr&gt;(&amp;self, key: impl AsRef&lt;str&gt;) -&gt; Result&lt;Option&lt;T&gt;, T::Err&gt;;
   fn get_value_or_default&lt;T&gt;(&amp;self, key: impl AsRef&lt;str&gt;) -&gt; Result&lt;T, T::Err&gt;
   where
       T: FromStr + Default;
}</code></pre>
<p>Consider the following struct:</p>
<pre><code class="language-rust">use serde::Deserialize;

#[derive(Default, Deserialize)]
#[serde(rename_all(deserialize = "PascalCase"))]
struct ContactOptions {
    name: String,
    primary: bool,
    phones: Vec&lt;String&gt;,
}</code></pre>
<blockquote>
<p>Configuration keys are normalized or expected to otherwise be Pascal Case for consistency.</p>
</blockquote>
<p>The following demonstrates how to load a configuration and then reify the configuration into the struct that was defined above. This example used the <a href="guide/memory.html">in-memory configuration provider</a>, but any configuration provider or multiple configuration providers can be used.</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_in_memory(&amp;[
            ("name", "John Doe"),
            ("primary", "true"),
            ("phones:0", "+44 1234567"),
            ("phones:1", "+44 2345678"),
        ])
        .build()
        .unwrap();

    let primary: bool = config.get_value_or_default("primary").unwrap();
    let options: ContactOptions = config.reify();

    println!("Is Primary: {}", primary);
    println!("{}", &amp;options.name);
    println!("Phones:");

    for phone in &amp;contact.phones {
        println!("\n  {}", phone);
    }
}</code></pre>
<p>It is also possible to bind an existing structure to an entire <a href="guide/abstractions.html#configuration">configuration</a> or bind at a specific <a href="guide/abstractions.html#configuration-section">configuration section</a>.</p>
<pre><code class="language-rust">use config::{*, ext::*};

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_in_memory(&amp;[
            ("name", "John Doe"),
            ("primary", "true"),
            ("phones:0", "+44 1234567"),
            ("phones:1", "+44 2345678"),
        ])
        .build()
        .unwrap();

    let mut options = ContactOptions::default();

    config.bind(&amp;mut options);

    println!("{}", &amp;options.name);
    println!("Phones:");

    for phone in &amp;contact.phones {
        println!("\n  {}", phone);
    }
}</code></pre>
<blockquote>
<p><strong>Note</strong>: The bound struct must implement <code>Deserialize::deserialize_in_place</code> to perform a true, in-place update. The default implementation creates a new struct and binds to it, which is essentially the same as mutating the struct to the result of <a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationBinder.html#method.reify"><code>reify</code></a>.</p>
</blockquote>
<h2 id="bind-an-array"><a class="header" href="#bind-an-array">Bind an Array</a></h2>
<p><a href="https://docs.rs/more-config/2.0.0/config/trait.ConfigurationBinder.html#method.bind"><code>bind</code></a> supports binding arrays to objects using array indices in configuration keys.</p>
<p>Consider <code>MyArray.json</code>:</p>
<pre><code class="language-json">{
  "array": {
    "entries": {
      "0": "value00",
      "1": "value10",
      "2": "value20",
      "4": "value40",
      "5": "value50"
    }
  }
}
</code></pre>
<p>The following code reads the configuration and displays the values:</p>
<pre><code class="language-rust">use config::{*, ext::*};
use serde::Deserialize;

#[derive(Default, Deserialize)]
#[serde(rename_all(deserialize = "PascalCase"))]
struct ArrayExample {
    entries: Vec&lt;String&gt;,
}

fn main() {
    let config = DefaultConfigurationBuilder::new()
        .add_json_file("MyArray.json")
        .build()
        .unwrap();
    let array: ArrayExample = config.reify();

    for (i, item) in array.entries.iter().enumerate() {
        println!("Index: {}, Value: {}", i, item );
    }
}</code></pre>
<p>The preceding code returns the following output. Note that index 3 has the value <code>value40</code>, which corresponds to <code>"4": "value40"</code> in <code>MyArray.json</code>. The bound array indices are continuous and not bound to the configuration key index. The configuration binder isn't capable of binding null values or creating null entries in bound objects; however, a missing value can be mapped to <code>Option</code>.</p>
<pre><code class="language-text">Index: 0  Value: value00
Index: 1  Value: value10
Index: 2  Value: value20
Index: 3  Value: value40
Index: 4  Value: value50
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>



        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
